// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef PROTOBUF_INCLUDED_messages_2eproto
#define PROTOBUF_INCLUDED_messages_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_messages_2eproto 

namespace protobuf_messages_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[20];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_messages_2eproto
class AccelerometerMeasurement;
class AccelerometerMeasurementDefaultTypeInternal;
extern AccelerometerMeasurementDefaultTypeInternal _AccelerometerMeasurement_default_instance_;
class ActuatorRequests;
class ActuatorRequestsDefaultTypeInternal;
extern ActuatorRequestsDefaultTypeInternal _ActuatorRequests_default_instance_;
class BumperMeasurement;
class BumperMeasurementDefaultTypeInternal;
extern BumperMeasurementDefaultTypeInternal _BumperMeasurement_default_instance_;
class CameraExposure;
class CameraExposureDefaultTypeInternal;
extern CameraExposureDefaultTypeInternal _CameraExposure_default_instance_;
class CameraMeasurement;
class CameraMeasurementDefaultTypeInternal;
extern CameraMeasurementDefaultTypeInternal _CameraMeasurement_default_instance_;
class CameraQuality;
class CameraQualityDefaultTypeInternal;
extern CameraQualityDefaultTypeInternal _CameraQuality_default_instance_;
class Force3DMeasurement;
class Force3DMeasurementDefaultTypeInternal;
extern Force3DMeasurementDefaultTypeInternal _Force3DMeasurement_default_instance_;
class Force6DMeasurement;
class Force6DMeasurementDefaultTypeInternal;
extern Force6DMeasurementDefaultTypeInternal _Force6DMeasurement_default_instance_;
class ForceMeasurement;
class ForceMeasurementDefaultTypeInternal;
extern ForceMeasurementDefaultTypeInternal _ForceMeasurement_default_instance_;
class GyroMeasurement;
class GyroMeasurementDefaultTypeInternal;
extern GyroMeasurementDefaultTypeInternal _GyroMeasurement_default_instance_;
class Message;
class MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class MotorForce;
class MotorForceDefaultTypeInternal;
extern MotorForceDefaultTypeInternal _MotorForce_default_instance_;
class MotorPID;
class MotorPIDDefaultTypeInternal;
extern MotorPIDDefaultTypeInternal _MotorPID_default_instance_;
class MotorPosition;
class MotorPositionDefaultTypeInternal;
extern MotorPositionDefaultTypeInternal _MotorPosition_default_instance_;
class MotorTorque;
class MotorTorqueDefaultTypeInternal;
extern MotorTorqueDefaultTypeInternal _MotorTorque_default_instance_;
class MotorVelocity;
class MotorVelocityDefaultTypeInternal;
extern MotorVelocityDefaultTypeInternal _MotorVelocity_default_instance_;
class PositionSensorMeasurement;
class PositionSensorMeasurementDefaultTypeInternal;
extern PositionSensorMeasurementDefaultTypeInternal _PositionSensorMeasurement_default_instance_;
class SensorMeasurements;
class SensorMeasurementsDefaultTypeInternal;
extern SensorMeasurementsDefaultTypeInternal _SensorMeasurements_default_instance_;
class SensorTimeStep;
class SensorTimeStepDefaultTypeInternal;
extern SensorTimeStepDefaultTypeInternal _SensorTimeStep_default_instance_;
class Vector3;
class Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
namespace google {
namespace protobuf {
template<> ::AccelerometerMeasurement* Arena::CreateMaybeMessage<::AccelerometerMeasurement>(Arena*);
template<> ::ActuatorRequests* Arena::CreateMaybeMessage<::ActuatorRequests>(Arena*);
template<> ::BumperMeasurement* Arena::CreateMaybeMessage<::BumperMeasurement>(Arena*);
template<> ::CameraExposure* Arena::CreateMaybeMessage<::CameraExposure>(Arena*);
template<> ::CameraMeasurement* Arena::CreateMaybeMessage<::CameraMeasurement>(Arena*);
template<> ::CameraQuality* Arena::CreateMaybeMessage<::CameraQuality>(Arena*);
template<> ::Force3DMeasurement* Arena::CreateMaybeMessage<::Force3DMeasurement>(Arena*);
template<> ::Force6DMeasurement* Arena::CreateMaybeMessage<::Force6DMeasurement>(Arena*);
template<> ::ForceMeasurement* Arena::CreateMaybeMessage<::ForceMeasurement>(Arena*);
template<> ::GyroMeasurement* Arena::CreateMaybeMessage<::GyroMeasurement>(Arena*);
template<> ::Message* Arena::CreateMaybeMessage<::Message>(Arena*);
template<> ::MotorForce* Arena::CreateMaybeMessage<::MotorForce>(Arena*);
template<> ::MotorPID* Arena::CreateMaybeMessage<::MotorPID>(Arena*);
template<> ::MotorPosition* Arena::CreateMaybeMessage<::MotorPosition>(Arena*);
template<> ::MotorTorque* Arena::CreateMaybeMessage<::MotorTorque>(Arena*);
template<> ::MotorVelocity* Arena::CreateMaybeMessage<::MotorVelocity>(Arena*);
template<> ::PositionSensorMeasurement* Arena::CreateMaybeMessage<::PositionSensorMeasurement>(Arena*);
template<> ::SensorMeasurements* Arena::CreateMaybeMessage<::SensorMeasurements>(Arena*);
template<> ::SensorTimeStep* Arena::CreateMaybeMessage<::SensorTimeStep>(Arena*);
template<> ::Vector3* Arena::CreateMaybeMessage<::Vector3>(Arena*);
}  // namespace protobuf
}  // namespace google

enum Message_MessageType {
  Message_MessageType_ERROR_MESSAGE = 0,
  Message_MessageType_WARNING_MESSAGE = 1,
  Message_MessageType_Message_MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Message_MessageType_Message_MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Message_MessageType_IsValid(int value);
const Message_MessageType Message_MessageType_MessageType_MIN = Message_MessageType_ERROR_MESSAGE;
const Message_MessageType Message_MessageType_MessageType_MAX = Message_MessageType_WARNING_MESSAGE;
const int Message_MessageType_MessageType_ARRAYSIZE = Message_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_MessageType_descriptor();
inline const ::std::string& Message_MessageType_Name(Message_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_MessageType_descriptor(), value);
}
inline bool Message_MessageType_Parse(
    const ::std::string& name, Message_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_MessageType>(
    Message_MessageType_descriptor(), name, value);
}
// ===================================================================

class Vector3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Vector3) */ {
 public:
  Vector3();
  virtual ~Vector3();

  Vector3(const Vector3& from);

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector3(Vector3&& from) noexcept
    : Vector3() {
    *this = ::std::move(from);
  }

  inline Vector3& operator=(Vector3&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
               &_Vector3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Vector3* other);
  friend void swap(Vector3& a, Vector3& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector3* New() const final {
    return CreateMaybeMessage<Vector3>(NULL);
  }

  Vector3* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vector3>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vector3& from);
  void MergeFrom(const Vector3& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double X = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // double Y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // double Z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:Vector3)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double x_;
  double y_;
  double z_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PositionSensorMeasurement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PositionSensorMeasurement) */ {
 public:
  PositionSensorMeasurement();
  virtual ~PositionSensorMeasurement();

  PositionSensorMeasurement(const PositionSensorMeasurement& from);

  inline PositionSensorMeasurement& operator=(const PositionSensorMeasurement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PositionSensorMeasurement(PositionSensorMeasurement&& from) noexcept
    : PositionSensorMeasurement() {
    *this = ::std::move(from);
  }

  inline PositionSensorMeasurement& operator=(PositionSensorMeasurement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PositionSensorMeasurement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PositionSensorMeasurement* internal_default_instance() {
    return reinterpret_cast<const PositionSensorMeasurement*>(
               &_PositionSensorMeasurement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(PositionSensorMeasurement* other);
  friend void swap(PositionSensorMeasurement& a, PositionSensorMeasurement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PositionSensorMeasurement* New() const final {
    return CreateMaybeMessage<PositionSensorMeasurement>(NULL);
  }

  PositionSensorMeasurement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PositionSensorMeasurement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PositionSensorMeasurement& from);
  void MergeFrom(const PositionSensorMeasurement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositionSensorMeasurement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // double value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  double value() const;
  void set_value(double value);

  // @@protoc_insertion_point(class_scope:PositionSensorMeasurement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  double value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccelerometerMeasurement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AccelerometerMeasurement) */ {
 public:
  AccelerometerMeasurement();
  virtual ~AccelerometerMeasurement();

  AccelerometerMeasurement(const AccelerometerMeasurement& from);

  inline AccelerometerMeasurement& operator=(const AccelerometerMeasurement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccelerometerMeasurement(AccelerometerMeasurement&& from) noexcept
    : AccelerometerMeasurement() {
    *this = ::std::move(from);
  }

  inline AccelerometerMeasurement& operator=(AccelerometerMeasurement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccelerometerMeasurement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccelerometerMeasurement* internal_default_instance() {
    return reinterpret_cast<const AccelerometerMeasurement*>(
               &_AccelerometerMeasurement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(AccelerometerMeasurement* other);
  friend void swap(AccelerometerMeasurement& a, AccelerometerMeasurement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccelerometerMeasurement* New() const final {
    return CreateMaybeMessage<AccelerometerMeasurement>(NULL);
  }

  AccelerometerMeasurement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccelerometerMeasurement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccelerometerMeasurement& from);
  void MergeFrom(const AccelerometerMeasurement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccelerometerMeasurement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .Vector3 value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  private:
  const ::Vector3& _internal_value() const;
  public:
  const ::Vector3& value() const;
  ::Vector3* release_value();
  ::Vector3* mutable_value();
  void set_allocated_value(::Vector3* value);

  // @@protoc_insertion_point(class_scope:AccelerometerMeasurement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::Vector3* value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GyroMeasurement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GyroMeasurement) */ {
 public:
  GyroMeasurement();
  virtual ~GyroMeasurement();

  GyroMeasurement(const GyroMeasurement& from);

  inline GyroMeasurement& operator=(const GyroMeasurement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GyroMeasurement(GyroMeasurement&& from) noexcept
    : GyroMeasurement() {
    *this = ::std::move(from);
  }

  inline GyroMeasurement& operator=(GyroMeasurement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GyroMeasurement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GyroMeasurement* internal_default_instance() {
    return reinterpret_cast<const GyroMeasurement*>(
               &_GyroMeasurement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GyroMeasurement* other);
  friend void swap(GyroMeasurement& a, GyroMeasurement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GyroMeasurement* New() const final {
    return CreateMaybeMessage<GyroMeasurement>(NULL);
  }

  GyroMeasurement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GyroMeasurement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GyroMeasurement& from);
  void MergeFrom(const GyroMeasurement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GyroMeasurement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .Vector3 value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  private:
  const ::Vector3& _internal_value() const;
  public:
  const ::Vector3& value() const;
  ::Vector3* release_value();
  ::Vector3* mutable_value();
  void set_allocated_value(::Vector3* value);

  // @@protoc_insertion_point(class_scope:GyroMeasurement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::Vector3* value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BumperMeasurement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BumperMeasurement) */ {
 public:
  BumperMeasurement();
  virtual ~BumperMeasurement();

  BumperMeasurement(const BumperMeasurement& from);

  inline BumperMeasurement& operator=(const BumperMeasurement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BumperMeasurement(BumperMeasurement&& from) noexcept
    : BumperMeasurement() {
    *this = ::std::move(from);
  }

  inline BumperMeasurement& operator=(BumperMeasurement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BumperMeasurement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BumperMeasurement* internal_default_instance() {
    return reinterpret_cast<const BumperMeasurement*>(
               &_BumperMeasurement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(BumperMeasurement* other);
  friend void swap(BumperMeasurement& a, BumperMeasurement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BumperMeasurement* New() const final {
    return CreateMaybeMessage<BumperMeasurement>(NULL);
  }

  BumperMeasurement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BumperMeasurement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BumperMeasurement& from);
  void MergeFrom(const BumperMeasurement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BumperMeasurement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bool value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  bool value() const;
  void set_value(bool value);

  // @@protoc_insertion_point(class_scope:BumperMeasurement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ForceMeasurement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ForceMeasurement) */ {
 public:
  ForceMeasurement();
  virtual ~ForceMeasurement();

  ForceMeasurement(const ForceMeasurement& from);

  inline ForceMeasurement& operator=(const ForceMeasurement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ForceMeasurement(ForceMeasurement&& from) noexcept
    : ForceMeasurement() {
    *this = ::std::move(from);
  }

  inline ForceMeasurement& operator=(ForceMeasurement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ForceMeasurement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ForceMeasurement* internal_default_instance() {
    return reinterpret_cast<const ForceMeasurement*>(
               &_ForceMeasurement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ForceMeasurement* other);
  friend void swap(ForceMeasurement& a, ForceMeasurement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ForceMeasurement* New() const final {
    return CreateMaybeMessage<ForceMeasurement>(NULL);
  }

  ForceMeasurement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ForceMeasurement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ForceMeasurement& from);
  void MergeFrom(const ForceMeasurement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForceMeasurement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // double value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  double value() const;
  void set_value(double value);

  // @@protoc_insertion_point(class_scope:ForceMeasurement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  double value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Force3DMeasurement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Force3DMeasurement) */ {
 public:
  Force3DMeasurement();
  virtual ~Force3DMeasurement();

  Force3DMeasurement(const Force3DMeasurement& from);

  inline Force3DMeasurement& operator=(const Force3DMeasurement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Force3DMeasurement(Force3DMeasurement&& from) noexcept
    : Force3DMeasurement() {
    *this = ::std::move(from);
  }

  inline Force3DMeasurement& operator=(Force3DMeasurement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Force3DMeasurement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Force3DMeasurement* internal_default_instance() {
    return reinterpret_cast<const Force3DMeasurement*>(
               &_Force3DMeasurement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Force3DMeasurement* other);
  friend void swap(Force3DMeasurement& a, Force3DMeasurement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Force3DMeasurement* New() const final {
    return CreateMaybeMessage<Force3DMeasurement>(NULL);
  }

  Force3DMeasurement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Force3DMeasurement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Force3DMeasurement& from);
  void MergeFrom(const Force3DMeasurement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Force3DMeasurement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .Vector3 value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  private:
  const ::Vector3& _internal_value() const;
  public:
  const ::Vector3& value() const;
  ::Vector3* release_value();
  ::Vector3* mutable_value();
  void set_allocated_value(::Vector3* value);

  // @@protoc_insertion_point(class_scope:Force3DMeasurement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::Vector3* value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Force6DMeasurement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Force6DMeasurement) */ {
 public:
  Force6DMeasurement();
  virtual ~Force6DMeasurement();

  Force6DMeasurement(const Force6DMeasurement& from);

  inline Force6DMeasurement& operator=(const Force6DMeasurement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Force6DMeasurement(Force6DMeasurement&& from) noexcept
    : Force6DMeasurement() {
    *this = ::std::move(from);
  }

  inline Force6DMeasurement& operator=(Force6DMeasurement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Force6DMeasurement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Force6DMeasurement* internal_default_instance() {
    return reinterpret_cast<const Force6DMeasurement*>(
               &_Force6DMeasurement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Force6DMeasurement* other);
  friend void swap(Force6DMeasurement& a, Force6DMeasurement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Force6DMeasurement* New() const final {
    return CreateMaybeMessage<Force6DMeasurement>(NULL);
  }

  Force6DMeasurement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Force6DMeasurement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Force6DMeasurement& from);
  void MergeFrom(const Force6DMeasurement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Force6DMeasurement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .Vector3 force = 2;
  bool has_force() const;
  void clear_force();
  static const int kForceFieldNumber = 2;
  private:
  const ::Vector3& _internal_force() const;
  public:
  const ::Vector3& force() const;
  ::Vector3* release_force();
  ::Vector3* mutable_force();
  void set_allocated_force(::Vector3* force);

  // .Vector3 torque = 3;
  bool has_torque() const;
  void clear_torque();
  static const int kTorqueFieldNumber = 3;
  private:
  const ::Vector3& _internal_torque() const;
  public:
  const ::Vector3& torque() const;
  ::Vector3* release_torque();
  ::Vector3* mutable_torque();
  void set_allocated_torque(::Vector3* torque);

  // @@protoc_insertion_point(class_scope:Force6DMeasurement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::Vector3* force_;
  ::Vector3* torque_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CameraMeasurement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CameraMeasurement) */ {
 public:
  CameraMeasurement();
  virtual ~CameraMeasurement();

  CameraMeasurement(const CameraMeasurement& from);

  inline CameraMeasurement& operator=(const CameraMeasurement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CameraMeasurement(CameraMeasurement&& from) noexcept
    : CameraMeasurement() {
    *this = ::std::move(from);
  }

  inline CameraMeasurement& operator=(CameraMeasurement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraMeasurement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraMeasurement* internal_default_instance() {
    return reinterpret_cast<const CameraMeasurement*>(
               &_CameraMeasurement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(CameraMeasurement* other);
  friend void swap(CameraMeasurement& a, CameraMeasurement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CameraMeasurement* New() const final {
    return CreateMaybeMessage<CameraMeasurement>(NULL);
  }

  CameraMeasurement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CameraMeasurement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CameraMeasurement& from);
  void MergeFrom(const CameraMeasurement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraMeasurement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bytes image = 5;
  void clear_image();
  static const int kImageFieldNumber = 5;
  const ::std::string& image() const;
  void set_image(const ::std::string& value);
  #if LANG_CXX11
  void set_image(::std::string&& value);
  #endif
  void set_image(const char* value);
  void set_image(const void* value, size_t size);
  ::std::string* mutable_image();
  ::std::string* release_image();
  void set_allocated_image(::std::string* image);

  // uint32 width = 2;
  void clear_width();
  static const int kWidthFieldNumber = 2;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // uint32 height = 3;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // sint32 quality = 4;
  void clear_quality();
  static const int kQualityFieldNumber = 4;
  ::google::protobuf::int32 quality() const;
  void set_quality(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CameraMeasurement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr image_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::int32 quality_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(Message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Message* other);
  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Message* New() const final {
    return CreateMaybeMessage<Message>(NULL);
  }

  Message* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Message_MessageType MessageType;
  static const MessageType ERROR_MESSAGE =
    Message_MessageType_ERROR_MESSAGE;
  static const MessageType WARNING_MESSAGE =
    Message_MessageType_WARNING_MESSAGE;
  static inline bool MessageType_IsValid(int value) {
    return Message_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    Message_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    Message_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    Message_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return Message_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return Message_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return Message_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string text = 2;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // .Message.MessageType message_type = 1;
  void clear_message_type();
  static const int kMessageTypeFieldNumber = 1;
  ::Message_MessageType message_type() const;
  void set_message_type(::Message_MessageType value);

  // @@protoc_insertion_point(class_scope:Message)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  int message_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SensorMeasurements : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SensorMeasurements) */ {
 public:
  SensorMeasurements();
  virtual ~SensorMeasurements();

  SensorMeasurements(const SensorMeasurements& from);

  inline SensorMeasurements& operator=(const SensorMeasurements& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SensorMeasurements(SensorMeasurements&& from) noexcept
    : SensorMeasurements() {
    *this = ::std::move(from);
  }

  inline SensorMeasurements& operator=(SensorMeasurements&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorMeasurements& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorMeasurements* internal_default_instance() {
    return reinterpret_cast<const SensorMeasurements*>(
               &_SensorMeasurements_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(SensorMeasurements* other);
  friend void swap(SensorMeasurements& a, SensorMeasurements& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorMeasurements* New() const final {
    return CreateMaybeMessage<SensorMeasurements>(NULL);
  }

  SensorMeasurements* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SensorMeasurements>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SensorMeasurements& from);
  void MergeFrom(const SensorMeasurements& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorMeasurements* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Message messages = 3;
  int messages_size() const;
  void clear_messages();
  static const int kMessagesFieldNumber = 3;
  ::Message* mutable_messages(int index);
  ::google::protobuf::RepeatedPtrField< ::Message >*
      mutable_messages();
  const ::Message& messages(int index) const;
  ::Message* add_messages();
  const ::google::protobuf::RepeatedPtrField< ::Message >&
      messages() const;

  // repeated .AccelerometerMeasurement accelerometers = 4;
  int accelerometers_size() const;
  void clear_accelerometers();
  static const int kAccelerometersFieldNumber = 4;
  ::AccelerometerMeasurement* mutable_accelerometers(int index);
  ::google::protobuf::RepeatedPtrField< ::AccelerometerMeasurement >*
      mutable_accelerometers();
  const ::AccelerometerMeasurement& accelerometers(int index) const;
  ::AccelerometerMeasurement* add_accelerometers();
  const ::google::protobuf::RepeatedPtrField< ::AccelerometerMeasurement >&
      accelerometers() const;

  // repeated .BumperMeasurement bumpers = 5;
  int bumpers_size() const;
  void clear_bumpers();
  static const int kBumpersFieldNumber = 5;
  ::BumperMeasurement* mutable_bumpers(int index);
  ::google::protobuf::RepeatedPtrField< ::BumperMeasurement >*
      mutable_bumpers();
  const ::BumperMeasurement& bumpers(int index) const;
  ::BumperMeasurement* add_bumpers();
  const ::google::protobuf::RepeatedPtrField< ::BumperMeasurement >&
      bumpers() const;

  // repeated .CameraMeasurement cameras = 6;
  int cameras_size() const;
  void clear_cameras();
  static const int kCamerasFieldNumber = 6;
  ::CameraMeasurement* mutable_cameras(int index);
  ::google::protobuf::RepeatedPtrField< ::CameraMeasurement >*
      mutable_cameras();
  const ::CameraMeasurement& cameras(int index) const;
  ::CameraMeasurement* add_cameras();
  const ::google::protobuf::RepeatedPtrField< ::CameraMeasurement >&
      cameras() const;

  // repeated .ForceMeasurement forces = 7;
  int forces_size() const;
  void clear_forces();
  static const int kForcesFieldNumber = 7;
  ::ForceMeasurement* mutable_forces(int index);
  ::google::protobuf::RepeatedPtrField< ::ForceMeasurement >*
      mutable_forces();
  const ::ForceMeasurement& forces(int index) const;
  ::ForceMeasurement* add_forces();
  const ::google::protobuf::RepeatedPtrField< ::ForceMeasurement >&
      forces() const;

  // repeated .Force3DMeasurement force3ds = 8;
  int force3ds_size() const;
  void clear_force3ds();
  static const int kForce3DsFieldNumber = 8;
  ::Force3DMeasurement* mutable_force3ds(int index);
  ::google::protobuf::RepeatedPtrField< ::Force3DMeasurement >*
      mutable_force3ds();
  const ::Force3DMeasurement& force3ds(int index) const;
  ::Force3DMeasurement* add_force3ds();
  const ::google::protobuf::RepeatedPtrField< ::Force3DMeasurement >&
      force3ds() const;

  // repeated .Force6DMeasurement force6ds = 9;
  int force6ds_size() const;
  void clear_force6ds();
  static const int kForce6DsFieldNumber = 9;
  ::Force6DMeasurement* mutable_force6ds(int index);
  ::google::protobuf::RepeatedPtrField< ::Force6DMeasurement >*
      mutable_force6ds();
  const ::Force6DMeasurement& force6ds(int index) const;
  ::Force6DMeasurement* add_force6ds();
  const ::google::protobuf::RepeatedPtrField< ::Force6DMeasurement >&
      force6ds() const;

  // repeated .GyroMeasurement gyros = 10;
  int gyros_size() const;
  void clear_gyros();
  static const int kGyrosFieldNumber = 10;
  ::GyroMeasurement* mutable_gyros(int index);
  ::google::protobuf::RepeatedPtrField< ::GyroMeasurement >*
      mutable_gyros();
  const ::GyroMeasurement& gyros(int index) const;
  ::GyroMeasurement* add_gyros();
  const ::google::protobuf::RepeatedPtrField< ::GyroMeasurement >&
      gyros() const;

  // repeated .PositionSensorMeasurement position_sensors = 11;
  int position_sensors_size() const;
  void clear_position_sensors();
  static const int kPositionSensorsFieldNumber = 11;
  ::PositionSensorMeasurement* mutable_position_sensors(int index);
  ::google::protobuf::RepeatedPtrField< ::PositionSensorMeasurement >*
      mutable_position_sensors();
  const ::PositionSensorMeasurement& position_sensors(int index) const;
  ::PositionSensorMeasurement* add_position_sensors();
  const ::google::protobuf::RepeatedPtrField< ::PositionSensorMeasurement >&
      position_sensors() const;

  // uint64 real_time = 2;
  void clear_real_time();
  static const int kRealTimeFieldNumber = 2;
  ::google::protobuf::uint64 real_time() const;
  void set_real_time(::google::protobuf::uint64 value);

  // uint32 time = 1;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::uint32 time() const;
  void set_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SensorMeasurements)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Message > messages_;
  ::google::protobuf::RepeatedPtrField< ::AccelerometerMeasurement > accelerometers_;
  ::google::protobuf::RepeatedPtrField< ::BumperMeasurement > bumpers_;
  ::google::protobuf::RepeatedPtrField< ::CameraMeasurement > cameras_;
  ::google::protobuf::RepeatedPtrField< ::ForceMeasurement > forces_;
  ::google::protobuf::RepeatedPtrField< ::Force3DMeasurement > force3ds_;
  ::google::protobuf::RepeatedPtrField< ::Force6DMeasurement > force6ds_;
  ::google::protobuf::RepeatedPtrField< ::GyroMeasurement > gyros_;
  ::google::protobuf::RepeatedPtrField< ::PositionSensorMeasurement > position_sensors_;
  ::google::protobuf::uint64 real_time_;
  ::google::protobuf::uint32 time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MotorPosition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MotorPosition) */ {
 public:
  MotorPosition();
  virtual ~MotorPosition();

  MotorPosition(const MotorPosition& from);

  inline MotorPosition& operator=(const MotorPosition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MotorPosition(MotorPosition&& from) noexcept
    : MotorPosition() {
    *this = ::std::move(from);
  }

  inline MotorPosition& operator=(MotorPosition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MotorPosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MotorPosition* internal_default_instance() {
    return reinterpret_cast<const MotorPosition*>(
               &_MotorPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(MotorPosition* other);
  friend void swap(MotorPosition& a, MotorPosition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MotorPosition* New() const final {
    return CreateMaybeMessage<MotorPosition>(NULL);
  }

  MotorPosition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MotorPosition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MotorPosition& from);
  void MergeFrom(const MotorPosition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotorPosition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // double position = 2;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  double position() const;
  void set_position(double value);

  // @@protoc_insertion_point(class_scope:MotorPosition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  double position_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MotorVelocity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MotorVelocity) */ {
 public:
  MotorVelocity();
  virtual ~MotorVelocity();

  MotorVelocity(const MotorVelocity& from);

  inline MotorVelocity& operator=(const MotorVelocity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MotorVelocity(MotorVelocity&& from) noexcept
    : MotorVelocity() {
    *this = ::std::move(from);
  }

  inline MotorVelocity& operator=(MotorVelocity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MotorVelocity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MotorVelocity* internal_default_instance() {
    return reinterpret_cast<const MotorVelocity*>(
               &_MotorVelocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(MotorVelocity* other);
  friend void swap(MotorVelocity& a, MotorVelocity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MotorVelocity* New() const final {
    return CreateMaybeMessage<MotorVelocity>(NULL);
  }

  MotorVelocity* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MotorVelocity>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MotorVelocity& from);
  void MergeFrom(const MotorVelocity& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotorVelocity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // double velocity = 2;
  void clear_velocity();
  static const int kVelocityFieldNumber = 2;
  double velocity() const;
  void set_velocity(double value);

  // @@protoc_insertion_point(class_scope:MotorVelocity)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  double velocity_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MotorForce : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MotorForce) */ {
 public:
  MotorForce();
  virtual ~MotorForce();

  MotorForce(const MotorForce& from);

  inline MotorForce& operator=(const MotorForce& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MotorForce(MotorForce&& from) noexcept
    : MotorForce() {
    *this = ::std::move(from);
  }

  inline MotorForce& operator=(MotorForce&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MotorForce& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MotorForce* internal_default_instance() {
    return reinterpret_cast<const MotorForce*>(
               &_MotorForce_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(MotorForce* other);
  friend void swap(MotorForce& a, MotorForce& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MotorForce* New() const final {
    return CreateMaybeMessage<MotorForce>(NULL);
  }

  MotorForce* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MotorForce>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MotorForce& from);
  void MergeFrom(const MotorForce& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotorForce* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // double force = 2;
  void clear_force();
  static const int kForceFieldNumber = 2;
  double force() const;
  void set_force(double value);

  // @@protoc_insertion_point(class_scope:MotorForce)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  double force_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MotorTorque : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MotorTorque) */ {
 public:
  MotorTorque();
  virtual ~MotorTorque();

  MotorTorque(const MotorTorque& from);

  inline MotorTorque& operator=(const MotorTorque& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MotorTorque(MotorTorque&& from) noexcept
    : MotorTorque() {
    *this = ::std::move(from);
  }

  inline MotorTorque& operator=(MotorTorque&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MotorTorque& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MotorTorque* internal_default_instance() {
    return reinterpret_cast<const MotorTorque*>(
               &_MotorTorque_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(MotorTorque* other);
  friend void swap(MotorTorque& a, MotorTorque& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MotorTorque* New() const final {
    return CreateMaybeMessage<MotorTorque>(NULL);
  }

  MotorTorque* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MotorTorque>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MotorTorque& from);
  void MergeFrom(const MotorTorque& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotorTorque* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // double torque = 2;
  void clear_torque();
  static const int kTorqueFieldNumber = 2;
  double torque() const;
  void set_torque(double value);

  // @@protoc_insertion_point(class_scope:MotorTorque)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  double torque_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MotorPID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MotorPID) */ {
 public:
  MotorPID();
  virtual ~MotorPID();

  MotorPID(const MotorPID& from);

  inline MotorPID& operator=(const MotorPID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MotorPID(MotorPID&& from) noexcept
    : MotorPID() {
    *this = ::std::move(from);
  }

  inline MotorPID& operator=(MotorPID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MotorPID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MotorPID* internal_default_instance() {
    return reinterpret_cast<const MotorPID*>(
               &_MotorPID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(MotorPID* other);
  friend void swap(MotorPID& a, MotorPID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MotorPID* New() const final {
    return CreateMaybeMessage<MotorPID>(NULL);
  }

  MotorPID* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MotorPID>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MotorPID& from);
  void MergeFrom(const MotorPID& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotorPID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .Vector3 PID = 2;
  bool has_pid() const;
  void clear_pid();
  static const int kPIDFieldNumber = 2;
  private:
  const ::Vector3& _internal_pid() const;
  public:
  const ::Vector3& pid() const;
  ::Vector3* release_pid();
  ::Vector3* mutable_pid();
  void set_allocated_pid(::Vector3* pid);

  // @@protoc_insertion_point(class_scope:MotorPID)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::Vector3* pid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SensorTimeStep : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SensorTimeStep) */ {
 public:
  SensorTimeStep();
  virtual ~SensorTimeStep();

  SensorTimeStep(const SensorTimeStep& from);

  inline SensorTimeStep& operator=(const SensorTimeStep& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SensorTimeStep(SensorTimeStep&& from) noexcept
    : SensorTimeStep() {
    *this = ::std::move(from);
  }

  inline SensorTimeStep& operator=(SensorTimeStep&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorTimeStep& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorTimeStep* internal_default_instance() {
    return reinterpret_cast<const SensorTimeStep*>(
               &_SensorTimeStep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(SensorTimeStep* other);
  friend void swap(SensorTimeStep& a, SensorTimeStep& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorTimeStep* New() const final {
    return CreateMaybeMessage<SensorTimeStep>(NULL);
  }

  SensorTimeStep* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SensorTimeStep>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SensorTimeStep& from);
  void MergeFrom(const SensorTimeStep& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorTimeStep* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // uint32 timeStep = 2;
  void clear_timestep();
  static const int kTimeStepFieldNumber = 2;
  ::google::protobuf::uint32 timestep() const;
  void set_timestep(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SensorTimeStep)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 timestep_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CameraQuality : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CameraQuality) */ {
 public:
  CameraQuality();
  virtual ~CameraQuality();

  CameraQuality(const CameraQuality& from);

  inline CameraQuality& operator=(const CameraQuality& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CameraQuality(CameraQuality&& from) noexcept
    : CameraQuality() {
    *this = ::std::move(from);
  }

  inline CameraQuality& operator=(CameraQuality&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraQuality& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraQuality* internal_default_instance() {
    return reinterpret_cast<const CameraQuality*>(
               &_CameraQuality_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(CameraQuality* other);
  friend void swap(CameraQuality& a, CameraQuality& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CameraQuality* New() const final {
    return CreateMaybeMessage<CameraQuality>(NULL);
  }

  CameraQuality* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CameraQuality>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CameraQuality& from);
  void MergeFrom(const CameraQuality& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraQuality* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // sint32 quality = 2;
  void clear_quality();
  static const int kQualityFieldNumber = 2;
  ::google::protobuf::int32 quality() const;
  void set_quality(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CameraQuality)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 quality_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CameraExposure : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CameraExposure) */ {
 public:
  CameraExposure();
  virtual ~CameraExposure();

  CameraExposure(const CameraExposure& from);

  inline CameraExposure& operator=(const CameraExposure& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CameraExposure(CameraExposure&& from) noexcept
    : CameraExposure() {
    *this = ::std::move(from);
  }

  inline CameraExposure& operator=(CameraExposure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraExposure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraExposure* internal_default_instance() {
    return reinterpret_cast<const CameraExposure*>(
               &_CameraExposure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(CameraExposure* other);
  friend void swap(CameraExposure& a, CameraExposure& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CameraExposure* New() const final {
    return CreateMaybeMessage<CameraExposure>(NULL);
  }

  CameraExposure* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CameraExposure>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CameraExposure& from);
  void MergeFrom(const CameraExposure& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraExposure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // double exposure = 2;
  void clear_exposure();
  static const int kExposureFieldNumber = 2;
  double exposure() const;
  void set_exposure(double value);

  // @@protoc_insertion_point(class_scope:CameraExposure)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  double exposure_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActuatorRequests : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ActuatorRequests) */ {
 public:
  ActuatorRequests();
  virtual ~ActuatorRequests();

  ActuatorRequests(const ActuatorRequests& from);

  inline ActuatorRequests& operator=(const ActuatorRequests& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActuatorRequests(ActuatorRequests&& from) noexcept
    : ActuatorRequests() {
    *this = ::std::move(from);
  }

  inline ActuatorRequests& operator=(ActuatorRequests&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ActuatorRequests& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActuatorRequests* internal_default_instance() {
    return reinterpret_cast<const ActuatorRequests*>(
               &_ActuatorRequests_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(ActuatorRequests* other);
  friend void swap(ActuatorRequests& a, ActuatorRequests& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActuatorRequests* New() const final {
    return CreateMaybeMessage<ActuatorRequests>(NULL);
  }

  ActuatorRequests* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActuatorRequests>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActuatorRequests& from);
  void MergeFrom(const ActuatorRequests& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActuatorRequests* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MotorPosition motor_positions = 1;
  int motor_positions_size() const;
  void clear_motor_positions();
  static const int kMotorPositionsFieldNumber = 1;
  ::MotorPosition* mutable_motor_positions(int index);
  ::google::protobuf::RepeatedPtrField< ::MotorPosition >*
      mutable_motor_positions();
  const ::MotorPosition& motor_positions(int index) const;
  ::MotorPosition* add_motor_positions();
  const ::google::protobuf::RepeatedPtrField< ::MotorPosition >&
      motor_positions() const;

  // repeated .MotorVelocity motor_velocities = 2;
  int motor_velocities_size() const;
  void clear_motor_velocities();
  static const int kMotorVelocitiesFieldNumber = 2;
  ::MotorVelocity* mutable_motor_velocities(int index);
  ::google::protobuf::RepeatedPtrField< ::MotorVelocity >*
      mutable_motor_velocities();
  const ::MotorVelocity& motor_velocities(int index) const;
  ::MotorVelocity* add_motor_velocities();
  const ::google::protobuf::RepeatedPtrField< ::MotorVelocity >&
      motor_velocities() const;

  // repeated .MotorForce motor_forces = 3;
  int motor_forces_size() const;
  void clear_motor_forces();
  static const int kMotorForcesFieldNumber = 3;
  ::MotorForce* mutable_motor_forces(int index);
  ::google::protobuf::RepeatedPtrField< ::MotorForce >*
      mutable_motor_forces();
  const ::MotorForce& motor_forces(int index) const;
  ::MotorForce* add_motor_forces();
  const ::google::protobuf::RepeatedPtrField< ::MotorForce >&
      motor_forces() const;

  // repeated .MotorTorque motor_torques = 4;
  int motor_torques_size() const;
  void clear_motor_torques();
  static const int kMotorTorquesFieldNumber = 4;
  ::MotorTorque* mutable_motor_torques(int index);
  ::google::protobuf::RepeatedPtrField< ::MotorTorque >*
      mutable_motor_torques();
  const ::MotorTorque& motor_torques(int index) const;
  ::MotorTorque* add_motor_torques();
  const ::google::protobuf::RepeatedPtrField< ::MotorTorque >&
      motor_torques() const;

  // repeated .MotorPID motor_pids = 5;
  int motor_pids_size() const;
  void clear_motor_pids();
  static const int kMotorPidsFieldNumber = 5;
  ::MotorPID* mutable_motor_pids(int index);
  ::google::protobuf::RepeatedPtrField< ::MotorPID >*
      mutable_motor_pids();
  const ::MotorPID& motor_pids(int index) const;
  ::MotorPID* add_motor_pids();
  const ::google::protobuf::RepeatedPtrField< ::MotorPID >&
      motor_pids() const;

  // repeated .SensorTimeStep sensor_time_steps = 6;
  int sensor_time_steps_size() const;
  void clear_sensor_time_steps();
  static const int kSensorTimeStepsFieldNumber = 6;
  ::SensorTimeStep* mutable_sensor_time_steps(int index);
  ::google::protobuf::RepeatedPtrField< ::SensorTimeStep >*
      mutable_sensor_time_steps();
  const ::SensorTimeStep& sensor_time_steps(int index) const;
  ::SensorTimeStep* add_sensor_time_steps();
  const ::google::protobuf::RepeatedPtrField< ::SensorTimeStep >&
      sensor_time_steps() const;

  // repeated .CameraQuality camera_qualities = 7;
  int camera_qualities_size() const;
  void clear_camera_qualities();
  static const int kCameraQualitiesFieldNumber = 7;
  ::CameraQuality* mutable_camera_qualities(int index);
  ::google::protobuf::RepeatedPtrField< ::CameraQuality >*
      mutable_camera_qualities();
  const ::CameraQuality& camera_qualities(int index) const;
  ::CameraQuality* add_camera_qualities();
  const ::google::protobuf::RepeatedPtrField< ::CameraQuality >&
      camera_qualities() const;

  // repeated .CameraExposure camera_exposures = 8;
  int camera_exposures_size() const;
  void clear_camera_exposures();
  static const int kCameraExposuresFieldNumber = 8;
  ::CameraExposure* mutable_camera_exposures(int index);
  ::google::protobuf::RepeatedPtrField< ::CameraExposure >*
      mutable_camera_exposures();
  const ::CameraExposure& camera_exposures(int index) const;
  ::CameraExposure* add_camera_exposures();
  const ::google::protobuf::RepeatedPtrField< ::CameraExposure >&
      camera_exposures() const;

  // @@protoc_insertion_point(class_scope:ActuatorRequests)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::MotorPosition > motor_positions_;
  ::google::protobuf::RepeatedPtrField< ::MotorVelocity > motor_velocities_;
  ::google::protobuf::RepeatedPtrField< ::MotorForce > motor_forces_;
  ::google::protobuf::RepeatedPtrField< ::MotorTorque > motor_torques_;
  ::google::protobuf::RepeatedPtrField< ::MotorPID > motor_pids_;
  ::google::protobuf::RepeatedPtrField< ::SensorTimeStep > sensor_time_steps_;
  ::google::protobuf::RepeatedPtrField< ::CameraQuality > camera_qualities_;
  ::google::protobuf::RepeatedPtrField< ::CameraExposure > camera_exposures_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vector3

// double X = 1;
inline void Vector3::clear_x() {
  x_ = 0;
}
inline double Vector3::x() const {
  // @@protoc_insertion_point(field_get:Vector3.X)
  return x_;
}
inline void Vector3::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Vector3.X)
}

// double Y = 2;
inline void Vector3::clear_y() {
  y_ = 0;
}
inline double Vector3::y() const {
  // @@protoc_insertion_point(field_get:Vector3.Y)
  return y_;
}
inline void Vector3::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Vector3.Y)
}

// double Z = 3;
inline void Vector3::clear_z() {
  z_ = 0;
}
inline double Vector3::z() const {
  // @@protoc_insertion_point(field_get:Vector3.Z)
  return z_;
}
inline void Vector3::set_z(double value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:Vector3.Z)
}

// -------------------------------------------------------------------

// PositionSensorMeasurement

// string name = 1;
inline void PositionSensorMeasurement::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PositionSensorMeasurement::name() const {
  // @@protoc_insertion_point(field_get:PositionSensorMeasurement.name)
  return name_.GetNoArena();
}
inline void PositionSensorMeasurement::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PositionSensorMeasurement.name)
}
#if LANG_CXX11
inline void PositionSensorMeasurement::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PositionSensorMeasurement.name)
}
#endif
inline void PositionSensorMeasurement::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PositionSensorMeasurement.name)
}
inline void PositionSensorMeasurement::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PositionSensorMeasurement.name)
}
inline ::std::string* PositionSensorMeasurement::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:PositionSensorMeasurement.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PositionSensorMeasurement::release_name() {
  // @@protoc_insertion_point(field_release:PositionSensorMeasurement.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PositionSensorMeasurement::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:PositionSensorMeasurement.name)
}

// double value = 2;
inline void PositionSensorMeasurement::clear_value() {
  value_ = 0;
}
inline double PositionSensorMeasurement::value() const {
  // @@protoc_insertion_point(field_get:PositionSensorMeasurement.value)
  return value_;
}
inline void PositionSensorMeasurement::set_value(double value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:PositionSensorMeasurement.value)
}

// -------------------------------------------------------------------

// AccelerometerMeasurement

// string name = 1;
inline void AccelerometerMeasurement::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccelerometerMeasurement::name() const {
  // @@protoc_insertion_point(field_get:AccelerometerMeasurement.name)
  return name_.GetNoArena();
}
inline void AccelerometerMeasurement::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AccelerometerMeasurement.name)
}
#if LANG_CXX11
inline void AccelerometerMeasurement::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AccelerometerMeasurement.name)
}
#endif
inline void AccelerometerMeasurement::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AccelerometerMeasurement.name)
}
inline void AccelerometerMeasurement::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AccelerometerMeasurement.name)
}
inline ::std::string* AccelerometerMeasurement::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:AccelerometerMeasurement.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccelerometerMeasurement::release_name() {
  // @@protoc_insertion_point(field_release:AccelerometerMeasurement.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccelerometerMeasurement::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:AccelerometerMeasurement.name)
}

// .Vector3 value = 2;
inline bool AccelerometerMeasurement::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void AccelerometerMeasurement::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) {
    delete value_;
  }
  value_ = NULL;
}
inline const ::Vector3& AccelerometerMeasurement::_internal_value() const {
  return *value_;
}
inline const ::Vector3& AccelerometerMeasurement::value() const {
  const ::Vector3* p = value_;
  // @@protoc_insertion_point(field_get:AccelerometerMeasurement.value)
  return p != NULL ? *p : *reinterpret_cast<const ::Vector3*>(
      &::_Vector3_default_instance_);
}
inline ::Vector3* AccelerometerMeasurement::release_value() {
  // @@protoc_insertion_point(field_release:AccelerometerMeasurement.value)
  
  ::Vector3* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::Vector3* AccelerometerMeasurement::mutable_value() {
  
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::Vector3>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AccelerometerMeasurement.value)
  return value_;
}
inline void AccelerometerMeasurement::set_allocated_value(::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete value_;
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:AccelerometerMeasurement.value)
}

// -------------------------------------------------------------------

// GyroMeasurement

// string name = 1;
inline void GyroMeasurement::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GyroMeasurement::name() const {
  // @@protoc_insertion_point(field_get:GyroMeasurement.name)
  return name_.GetNoArena();
}
inline void GyroMeasurement::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GyroMeasurement.name)
}
#if LANG_CXX11
inline void GyroMeasurement::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GyroMeasurement.name)
}
#endif
inline void GyroMeasurement::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GyroMeasurement.name)
}
inline void GyroMeasurement::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GyroMeasurement.name)
}
inline ::std::string* GyroMeasurement::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:GyroMeasurement.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GyroMeasurement::release_name() {
  // @@protoc_insertion_point(field_release:GyroMeasurement.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GyroMeasurement::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:GyroMeasurement.name)
}

// .Vector3 value = 2;
inline bool GyroMeasurement::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void GyroMeasurement::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) {
    delete value_;
  }
  value_ = NULL;
}
inline const ::Vector3& GyroMeasurement::_internal_value() const {
  return *value_;
}
inline const ::Vector3& GyroMeasurement::value() const {
  const ::Vector3* p = value_;
  // @@protoc_insertion_point(field_get:GyroMeasurement.value)
  return p != NULL ? *p : *reinterpret_cast<const ::Vector3*>(
      &::_Vector3_default_instance_);
}
inline ::Vector3* GyroMeasurement::release_value() {
  // @@protoc_insertion_point(field_release:GyroMeasurement.value)
  
  ::Vector3* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::Vector3* GyroMeasurement::mutable_value() {
  
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::Vector3>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:GyroMeasurement.value)
  return value_;
}
inline void GyroMeasurement::set_allocated_value(::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete value_;
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:GyroMeasurement.value)
}

// -------------------------------------------------------------------

// BumperMeasurement

// string name = 1;
inline void BumperMeasurement::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BumperMeasurement::name() const {
  // @@protoc_insertion_point(field_get:BumperMeasurement.name)
  return name_.GetNoArena();
}
inline void BumperMeasurement::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BumperMeasurement.name)
}
#if LANG_CXX11
inline void BumperMeasurement::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:BumperMeasurement.name)
}
#endif
inline void BumperMeasurement::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BumperMeasurement.name)
}
inline void BumperMeasurement::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BumperMeasurement.name)
}
inline ::std::string* BumperMeasurement::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:BumperMeasurement.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BumperMeasurement::release_name() {
  // @@protoc_insertion_point(field_release:BumperMeasurement.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BumperMeasurement::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:BumperMeasurement.name)
}

// bool value = 2;
inline void BumperMeasurement::clear_value() {
  value_ = false;
}
inline bool BumperMeasurement::value() const {
  // @@protoc_insertion_point(field_get:BumperMeasurement.value)
  return value_;
}
inline void BumperMeasurement::set_value(bool value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:BumperMeasurement.value)
}

// -------------------------------------------------------------------

// ForceMeasurement

// string name = 1;
inline void ForceMeasurement::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ForceMeasurement::name() const {
  // @@protoc_insertion_point(field_get:ForceMeasurement.name)
  return name_.GetNoArena();
}
inline void ForceMeasurement::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ForceMeasurement.name)
}
#if LANG_CXX11
inline void ForceMeasurement::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ForceMeasurement.name)
}
#endif
inline void ForceMeasurement::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ForceMeasurement.name)
}
inline void ForceMeasurement::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ForceMeasurement.name)
}
inline ::std::string* ForceMeasurement::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:ForceMeasurement.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ForceMeasurement::release_name() {
  // @@protoc_insertion_point(field_release:ForceMeasurement.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ForceMeasurement::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ForceMeasurement.name)
}

// double value = 2;
inline void ForceMeasurement::clear_value() {
  value_ = 0;
}
inline double ForceMeasurement::value() const {
  // @@protoc_insertion_point(field_get:ForceMeasurement.value)
  return value_;
}
inline void ForceMeasurement::set_value(double value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:ForceMeasurement.value)
}

// -------------------------------------------------------------------

// Force3DMeasurement

// string name = 1;
inline void Force3DMeasurement::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Force3DMeasurement::name() const {
  // @@protoc_insertion_point(field_get:Force3DMeasurement.name)
  return name_.GetNoArena();
}
inline void Force3DMeasurement::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Force3DMeasurement.name)
}
#if LANG_CXX11
inline void Force3DMeasurement::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Force3DMeasurement.name)
}
#endif
inline void Force3DMeasurement::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Force3DMeasurement.name)
}
inline void Force3DMeasurement::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Force3DMeasurement.name)
}
inline ::std::string* Force3DMeasurement::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Force3DMeasurement.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Force3DMeasurement::release_name() {
  // @@protoc_insertion_point(field_release:Force3DMeasurement.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Force3DMeasurement::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Force3DMeasurement.name)
}

// .Vector3 value = 2;
inline bool Force3DMeasurement::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void Force3DMeasurement::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) {
    delete value_;
  }
  value_ = NULL;
}
inline const ::Vector3& Force3DMeasurement::_internal_value() const {
  return *value_;
}
inline const ::Vector3& Force3DMeasurement::value() const {
  const ::Vector3* p = value_;
  // @@protoc_insertion_point(field_get:Force3DMeasurement.value)
  return p != NULL ? *p : *reinterpret_cast<const ::Vector3*>(
      &::_Vector3_default_instance_);
}
inline ::Vector3* Force3DMeasurement::release_value() {
  // @@protoc_insertion_point(field_release:Force3DMeasurement.value)
  
  ::Vector3* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::Vector3* Force3DMeasurement::mutable_value() {
  
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::Vector3>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Force3DMeasurement.value)
  return value_;
}
inline void Force3DMeasurement::set_allocated_value(::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete value_;
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:Force3DMeasurement.value)
}

// -------------------------------------------------------------------

// Force6DMeasurement

// string name = 1;
inline void Force6DMeasurement::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Force6DMeasurement::name() const {
  // @@protoc_insertion_point(field_get:Force6DMeasurement.name)
  return name_.GetNoArena();
}
inline void Force6DMeasurement::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Force6DMeasurement.name)
}
#if LANG_CXX11
inline void Force6DMeasurement::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Force6DMeasurement.name)
}
#endif
inline void Force6DMeasurement::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Force6DMeasurement.name)
}
inline void Force6DMeasurement::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Force6DMeasurement.name)
}
inline ::std::string* Force6DMeasurement::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Force6DMeasurement.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Force6DMeasurement::release_name() {
  // @@protoc_insertion_point(field_release:Force6DMeasurement.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Force6DMeasurement::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Force6DMeasurement.name)
}

// .Vector3 force = 2;
inline bool Force6DMeasurement::has_force() const {
  return this != internal_default_instance() && force_ != NULL;
}
inline void Force6DMeasurement::clear_force() {
  if (GetArenaNoVirtual() == NULL && force_ != NULL) {
    delete force_;
  }
  force_ = NULL;
}
inline const ::Vector3& Force6DMeasurement::_internal_force() const {
  return *force_;
}
inline const ::Vector3& Force6DMeasurement::force() const {
  const ::Vector3* p = force_;
  // @@protoc_insertion_point(field_get:Force6DMeasurement.force)
  return p != NULL ? *p : *reinterpret_cast<const ::Vector3*>(
      &::_Vector3_default_instance_);
}
inline ::Vector3* Force6DMeasurement::release_force() {
  // @@protoc_insertion_point(field_release:Force6DMeasurement.force)
  
  ::Vector3* temp = force_;
  force_ = NULL;
  return temp;
}
inline ::Vector3* Force6DMeasurement::mutable_force() {
  
  if (force_ == NULL) {
    auto* p = CreateMaybeMessage<::Vector3>(GetArenaNoVirtual());
    force_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Force6DMeasurement.force)
  return force_;
}
inline void Force6DMeasurement::set_allocated_force(::Vector3* force) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete force_;
  }
  if (force) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      force = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, force, submessage_arena);
    }
    
  } else {
    
  }
  force_ = force;
  // @@protoc_insertion_point(field_set_allocated:Force6DMeasurement.force)
}

// .Vector3 torque = 3;
inline bool Force6DMeasurement::has_torque() const {
  return this != internal_default_instance() && torque_ != NULL;
}
inline void Force6DMeasurement::clear_torque() {
  if (GetArenaNoVirtual() == NULL && torque_ != NULL) {
    delete torque_;
  }
  torque_ = NULL;
}
inline const ::Vector3& Force6DMeasurement::_internal_torque() const {
  return *torque_;
}
inline const ::Vector3& Force6DMeasurement::torque() const {
  const ::Vector3* p = torque_;
  // @@protoc_insertion_point(field_get:Force6DMeasurement.torque)
  return p != NULL ? *p : *reinterpret_cast<const ::Vector3*>(
      &::_Vector3_default_instance_);
}
inline ::Vector3* Force6DMeasurement::release_torque() {
  // @@protoc_insertion_point(field_release:Force6DMeasurement.torque)
  
  ::Vector3* temp = torque_;
  torque_ = NULL;
  return temp;
}
inline ::Vector3* Force6DMeasurement::mutable_torque() {
  
  if (torque_ == NULL) {
    auto* p = CreateMaybeMessage<::Vector3>(GetArenaNoVirtual());
    torque_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Force6DMeasurement.torque)
  return torque_;
}
inline void Force6DMeasurement::set_allocated_torque(::Vector3* torque) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete torque_;
  }
  if (torque) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      torque = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, torque, submessage_arena);
    }
    
  } else {
    
  }
  torque_ = torque;
  // @@protoc_insertion_point(field_set_allocated:Force6DMeasurement.torque)
}

// -------------------------------------------------------------------

// CameraMeasurement

// string name = 1;
inline void CameraMeasurement::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CameraMeasurement::name() const {
  // @@protoc_insertion_point(field_get:CameraMeasurement.name)
  return name_.GetNoArena();
}
inline void CameraMeasurement::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CameraMeasurement.name)
}
#if LANG_CXX11
inline void CameraMeasurement::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CameraMeasurement.name)
}
#endif
inline void CameraMeasurement::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CameraMeasurement.name)
}
inline void CameraMeasurement::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CameraMeasurement.name)
}
inline ::std::string* CameraMeasurement::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:CameraMeasurement.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CameraMeasurement::release_name() {
  // @@protoc_insertion_point(field_release:CameraMeasurement.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CameraMeasurement::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:CameraMeasurement.name)
}

// uint32 width = 2;
inline void CameraMeasurement::clear_width() {
  width_ = 0u;
}
inline ::google::protobuf::uint32 CameraMeasurement::width() const {
  // @@protoc_insertion_point(field_get:CameraMeasurement.width)
  return width_;
}
inline void CameraMeasurement::set_width(::google::protobuf::uint32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:CameraMeasurement.width)
}

// uint32 height = 3;
inline void CameraMeasurement::clear_height() {
  height_ = 0u;
}
inline ::google::protobuf::uint32 CameraMeasurement::height() const {
  // @@protoc_insertion_point(field_get:CameraMeasurement.height)
  return height_;
}
inline void CameraMeasurement::set_height(::google::protobuf::uint32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:CameraMeasurement.height)
}

// sint32 quality = 4;
inline void CameraMeasurement::clear_quality() {
  quality_ = 0;
}
inline ::google::protobuf::int32 CameraMeasurement::quality() const {
  // @@protoc_insertion_point(field_get:CameraMeasurement.quality)
  return quality_;
}
inline void CameraMeasurement::set_quality(::google::protobuf::int32 value) {
  
  quality_ = value;
  // @@protoc_insertion_point(field_set:CameraMeasurement.quality)
}

// bytes image = 5;
inline void CameraMeasurement::clear_image() {
  image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CameraMeasurement::image() const {
  // @@protoc_insertion_point(field_get:CameraMeasurement.image)
  return image_.GetNoArena();
}
inline void CameraMeasurement::set_image(const ::std::string& value) {
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CameraMeasurement.image)
}
#if LANG_CXX11
inline void CameraMeasurement::set_image(::std::string&& value) {
  
  image_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CameraMeasurement.image)
}
#endif
inline void CameraMeasurement::set_image(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CameraMeasurement.image)
}
inline void CameraMeasurement::set_image(const void* value, size_t size) {
  
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CameraMeasurement.image)
}
inline ::std::string* CameraMeasurement::mutable_image() {
  
  // @@protoc_insertion_point(field_mutable:CameraMeasurement.image)
  return image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CameraMeasurement::release_image() {
  // @@protoc_insertion_point(field_release:CameraMeasurement.image)
  
  return image_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CameraMeasurement::set_allocated_image(::std::string* image) {
  if (image != NULL) {
    
  } else {
    
  }
  image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image);
  // @@protoc_insertion_point(field_set_allocated:CameraMeasurement.image)
}

// -------------------------------------------------------------------

// Message

// .Message.MessageType message_type = 1;
inline void Message::clear_message_type() {
  message_type_ = 0;
}
inline ::Message_MessageType Message::message_type() const {
  // @@protoc_insertion_point(field_get:Message.message_type)
  return static_cast< ::Message_MessageType >(message_type_);
}
inline void Message::set_message_type(::Message_MessageType value) {
  
  message_type_ = value;
  // @@protoc_insertion_point(field_set:Message.message_type)
}

// string text = 2;
inline void Message::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message::text() const {
  // @@protoc_insertion_point(field_get:Message.text)
  return text_.GetNoArena();
}
inline void Message::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Message.text)
}
#if LANG_CXX11
inline void Message::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Message.text)
}
#endif
inline void Message::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Message.text)
}
inline void Message::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Message.text)
}
inline ::std::string* Message::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:Message.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_text() {
  // @@protoc_insertion_point(field_release:Message.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:Message.text)
}

// -------------------------------------------------------------------

// SensorMeasurements

// uint32 time = 1;
inline void SensorMeasurements::clear_time() {
  time_ = 0u;
}
inline ::google::protobuf::uint32 SensorMeasurements::time() const {
  // @@protoc_insertion_point(field_get:SensorMeasurements.time)
  return time_;
}
inline void SensorMeasurements::set_time(::google::protobuf::uint32 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:SensorMeasurements.time)
}

// uint64 real_time = 2;
inline void SensorMeasurements::clear_real_time() {
  real_time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SensorMeasurements::real_time() const {
  // @@protoc_insertion_point(field_get:SensorMeasurements.real_time)
  return real_time_;
}
inline void SensorMeasurements::set_real_time(::google::protobuf::uint64 value) {
  
  real_time_ = value;
  // @@protoc_insertion_point(field_set:SensorMeasurements.real_time)
}

// repeated .Message messages = 3;
inline int SensorMeasurements::messages_size() const {
  return messages_.size();
}
inline void SensorMeasurements::clear_messages() {
  messages_.Clear();
}
inline ::Message* SensorMeasurements::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:SensorMeasurements.messages)
  return messages_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Message >*
SensorMeasurements::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:SensorMeasurements.messages)
  return &messages_;
}
inline const ::Message& SensorMeasurements::messages(int index) const {
  // @@protoc_insertion_point(field_get:SensorMeasurements.messages)
  return messages_.Get(index);
}
inline ::Message* SensorMeasurements::add_messages() {
  // @@protoc_insertion_point(field_add:SensorMeasurements.messages)
  return messages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Message >&
SensorMeasurements::messages() const {
  // @@protoc_insertion_point(field_list:SensorMeasurements.messages)
  return messages_;
}

// repeated .AccelerometerMeasurement accelerometers = 4;
inline int SensorMeasurements::accelerometers_size() const {
  return accelerometers_.size();
}
inline void SensorMeasurements::clear_accelerometers() {
  accelerometers_.Clear();
}
inline ::AccelerometerMeasurement* SensorMeasurements::mutable_accelerometers(int index) {
  // @@protoc_insertion_point(field_mutable:SensorMeasurements.accelerometers)
  return accelerometers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::AccelerometerMeasurement >*
SensorMeasurements::mutable_accelerometers() {
  // @@protoc_insertion_point(field_mutable_list:SensorMeasurements.accelerometers)
  return &accelerometers_;
}
inline const ::AccelerometerMeasurement& SensorMeasurements::accelerometers(int index) const {
  // @@protoc_insertion_point(field_get:SensorMeasurements.accelerometers)
  return accelerometers_.Get(index);
}
inline ::AccelerometerMeasurement* SensorMeasurements::add_accelerometers() {
  // @@protoc_insertion_point(field_add:SensorMeasurements.accelerometers)
  return accelerometers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AccelerometerMeasurement >&
SensorMeasurements::accelerometers() const {
  // @@protoc_insertion_point(field_list:SensorMeasurements.accelerometers)
  return accelerometers_;
}

// repeated .BumperMeasurement bumpers = 5;
inline int SensorMeasurements::bumpers_size() const {
  return bumpers_.size();
}
inline void SensorMeasurements::clear_bumpers() {
  bumpers_.Clear();
}
inline ::BumperMeasurement* SensorMeasurements::mutable_bumpers(int index) {
  // @@protoc_insertion_point(field_mutable:SensorMeasurements.bumpers)
  return bumpers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::BumperMeasurement >*
SensorMeasurements::mutable_bumpers() {
  // @@protoc_insertion_point(field_mutable_list:SensorMeasurements.bumpers)
  return &bumpers_;
}
inline const ::BumperMeasurement& SensorMeasurements::bumpers(int index) const {
  // @@protoc_insertion_point(field_get:SensorMeasurements.bumpers)
  return bumpers_.Get(index);
}
inline ::BumperMeasurement* SensorMeasurements::add_bumpers() {
  // @@protoc_insertion_point(field_add:SensorMeasurements.bumpers)
  return bumpers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BumperMeasurement >&
SensorMeasurements::bumpers() const {
  // @@protoc_insertion_point(field_list:SensorMeasurements.bumpers)
  return bumpers_;
}

// repeated .CameraMeasurement cameras = 6;
inline int SensorMeasurements::cameras_size() const {
  return cameras_.size();
}
inline void SensorMeasurements::clear_cameras() {
  cameras_.Clear();
}
inline ::CameraMeasurement* SensorMeasurements::mutable_cameras(int index) {
  // @@protoc_insertion_point(field_mutable:SensorMeasurements.cameras)
  return cameras_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::CameraMeasurement >*
SensorMeasurements::mutable_cameras() {
  // @@protoc_insertion_point(field_mutable_list:SensorMeasurements.cameras)
  return &cameras_;
}
inline const ::CameraMeasurement& SensorMeasurements::cameras(int index) const {
  // @@protoc_insertion_point(field_get:SensorMeasurements.cameras)
  return cameras_.Get(index);
}
inline ::CameraMeasurement* SensorMeasurements::add_cameras() {
  // @@protoc_insertion_point(field_add:SensorMeasurements.cameras)
  return cameras_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CameraMeasurement >&
SensorMeasurements::cameras() const {
  // @@protoc_insertion_point(field_list:SensorMeasurements.cameras)
  return cameras_;
}

// repeated .ForceMeasurement forces = 7;
inline int SensorMeasurements::forces_size() const {
  return forces_.size();
}
inline void SensorMeasurements::clear_forces() {
  forces_.Clear();
}
inline ::ForceMeasurement* SensorMeasurements::mutable_forces(int index) {
  // @@protoc_insertion_point(field_mutable:SensorMeasurements.forces)
  return forces_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ForceMeasurement >*
SensorMeasurements::mutable_forces() {
  // @@protoc_insertion_point(field_mutable_list:SensorMeasurements.forces)
  return &forces_;
}
inline const ::ForceMeasurement& SensorMeasurements::forces(int index) const {
  // @@protoc_insertion_point(field_get:SensorMeasurements.forces)
  return forces_.Get(index);
}
inline ::ForceMeasurement* SensorMeasurements::add_forces() {
  // @@protoc_insertion_point(field_add:SensorMeasurements.forces)
  return forces_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ForceMeasurement >&
SensorMeasurements::forces() const {
  // @@protoc_insertion_point(field_list:SensorMeasurements.forces)
  return forces_;
}

// repeated .Force3DMeasurement force3ds = 8;
inline int SensorMeasurements::force3ds_size() const {
  return force3ds_.size();
}
inline void SensorMeasurements::clear_force3ds() {
  force3ds_.Clear();
}
inline ::Force3DMeasurement* SensorMeasurements::mutable_force3ds(int index) {
  // @@protoc_insertion_point(field_mutable:SensorMeasurements.force3ds)
  return force3ds_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Force3DMeasurement >*
SensorMeasurements::mutable_force3ds() {
  // @@protoc_insertion_point(field_mutable_list:SensorMeasurements.force3ds)
  return &force3ds_;
}
inline const ::Force3DMeasurement& SensorMeasurements::force3ds(int index) const {
  // @@protoc_insertion_point(field_get:SensorMeasurements.force3ds)
  return force3ds_.Get(index);
}
inline ::Force3DMeasurement* SensorMeasurements::add_force3ds() {
  // @@protoc_insertion_point(field_add:SensorMeasurements.force3ds)
  return force3ds_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Force3DMeasurement >&
SensorMeasurements::force3ds() const {
  // @@protoc_insertion_point(field_list:SensorMeasurements.force3ds)
  return force3ds_;
}

// repeated .Force6DMeasurement force6ds = 9;
inline int SensorMeasurements::force6ds_size() const {
  return force6ds_.size();
}
inline void SensorMeasurements::clear_force6ds() {
  force6ds_.Clear();
}
inline ::Force6DMeasurement* SensorMeasurements::mutable_force6ds(int index) {
  // @@protoc_insertion_point(field_mutable:SensorMeasurements.force6ds)
  return force6ds_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Force6DMeasurement >*
SensorMeasurements::mutable_force6ds() {
  // @@protoc_insertion_point(field_mutable_list:SensorMeasurements.force6ds)
  return &force6ds_;
}
inline const ::Force6DMeasurement& SensorMeasurements::force6ds(int index) const {
  // @@protoc_insertion_point(field_get:SensorMeasurements.force6ds)
  return force6ds_.Get(index);
}
inline ::Force6DMeasurement* SensorMeasurements::add_force6ds() {
  // @@protoc_insertion_point(field_add:SensorMeasurements.force6ds)
  return force6ds_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Force6DMeasurement >&
SensorMeasurements::force6ds() const {
  // @@protoc_insertion_point(field_list:SensorMeasurements.force6ds)
  return force6ds_;
}

// repeated .GyroMeasurement gyros = 10;
inline int SensorMeasurements::gyros_size() const {
  return gyros_.size();
}
inline void SensorMeasurements::clear_gyros() {
  gyros_.Clear();
}
inline ::GyroMeasurement* SensorMeasurements::mutable_gyros(int index) {
  // @@protoc_insertion_point(field_mutable:SensorMeasurements.gyros)
  return gyros_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::GyroMeasurement >*
SensorMeasurements::mutable_gyros() {
  // @@protoc_insertion_point(field_mutable_list:SensorMeasurements.gyros)
  return &gyros_;
}
inline const ::GyroMeasurement& SensorMeasurements::gyros(int index) const {
  // @@protoc_insertion_point(field_get:SensorMeasurements.gyros)
  return gyros_.Get(index);
}
inline ::GyroMeasurement* SensorMeasurements::add_gyros() {
  // @@protoc_insertion_point(field_add:SensorMeasurements.gyros)
  return gyros_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GyroMeasurement >&
SensorMeasurements::gyros() const {
  // @@protoc_insertion_point(field_list:SensorMeasurements.gyros)
  return gyros_;
}

// repeated .PositionSensorMeasurement position_sensors = 11;
inline int SensorMeasurements::position_sensors_size() const {
  return position_sensors_.size();
}
inline void SensorMeasurements::clear_position_sensors() {
  position_sensors_.Clear();
}
inline ::PositionSensorMeasurement* SensorMeasurements::mutable_position_sensors(int index) {
  // @@protoc_insertion_point(field_mutable:SensorMeasurements.position_sensors)
  return position_sensors_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::PositionSensorMeasurement >*
SensorMeasurements::mutable_position_sensors() {
  // @@protoc_insertion_point(field_mutable_list:SensorMeasurements.position_sensors)
  return &position_sensors_;
}
inline const ::PositionSensorMeasurement& SensorMeasurements::position_sensors(int index) const {
  // @@protoc_insertion_point(field_get:SensorMeasurements.position_sensors)
  return position_sensors_.Get(index);
}
inline ::PositionSensorMeasurement* SensorMeasurements::add_position_sensors() {
  // @@protoc_insertion_point(field_add:SensorMeasurements.position_sensors)
  return position_sensors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PositionSensorMeasurement >&
SensorMeasurements::position_sensors() const {
  // @@protoc_insertion_point(field_list:SensorMeasurements.position_sensors)
  return position_sensors_;
}

// -------------------------------------------------------------------

// MotorPosition

// string name = 1;
inline void MotorPosition::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MotorPosition::name() const {
  // @@protoc_insertion_point(field_get:MotorPosition.name)
  return name_.GetNoArena();
}
inline void MotorPosition::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MotorPosition.name)
}
#if LANG_CXX11
inline void MotorPosition::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MotorPosition.name)
}
#endif
inline void MotorPosition::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MotorPosition.name)
}
inline void MotorPosition::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MotorPosition.name)
}
inline ::std::string* MotorPosition::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:MotorPosition.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MotorPosition::release_name() {
  // @@protoc_insertion_point(field_release:MotorPosition.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MotorPosition::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MotorPosition.name)
}

// double position = 2;
inline void MotorPosition::clear_position() {
  position_ = 0;
}
inline double MotorPosition::position() const {
  // @@protoc_insertion_point(field_get:MotorPosition.position)
  return position_;
}
inline void MotorPosition::set_position(double value) {
  
  position_ = value;
  // @@protoc_insertion_point(field_set:MotorPosition.position)
}

// -------------------------------------------------------------------

// MotorVelocity

// string name = 1;
inline void MotorVelocity::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MotorVelocity::name() const {
  // @@protoc_insertion_point(field_get:MotorVelocity.name)
  return name_.GetNoArena();
}
inline void MotorVelocity::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MotorVelocity.name)
}
#if LANG_CXX11
inline void MotorVelocity::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MotorVelocity.name)
}
#endif
inline void MotorVelocity::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MotorVelocity.name)
}
inline void MotorVelocity::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MotorVelocity.name)
}
inline ::std::string* MotorVelocity::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:MotorVelocity.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MotorVelocity::release_name() {
  // @@protoc_insertion_point(field_release:MotorVelocity.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MotorVelocity::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MotorVelocity.name)
}

// double velocity = 2;
inline void MotorVelocity::clear_velocity() {
  velocity_ = 0;
}
inline double MotorVelocity::velocity() const {
  // @@protoc_insertion_point(field_get:MotorVelocity.velocity)
  return velocity_;
}
inline void MotorVelocity::set_velocity(double value) {
  
  velocity_ = value;
  // @@protoc_insertion_point(field_set:MotorVelocity.velocity)
}

// -------------------------------------------------------------------

// MotorForce

// string name = 1;
inline void MotorForce::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MotorForce::name() const {
  // @@protoc_insertion_point(field_get:MotorForce.name)
  return name_.GetNoArena();
}
inline void MotorForce::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MotorForce.name)
}
#if LANG_CXX11
inline void MotorForce::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MotorForce.name)
}
#endif
inline void MotorForce::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MotorForce.name)
}
inline void MotorForce::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MotorForce.name)
}
inline ::std::string* MotorForce::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:MotorForce.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MotorForce::release_name() {
  // @@protoc_insertion_point(field_release:MotorForce.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MotorForce::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MotorForce.name)
}

// double force = 2;
inline void MotorForce::clear_force() {
  force_ = 0;
}
inline double MotorForce::force() const {
  // @@protoc_insertion_point(field_get:MotorForce.force)
  return force_;
}
inline void MotorForce::set_force(double value) {
  
  force_ = value;
  // @@protoc_insertion_point(field_set:MotorForce.force)
}

// -------------------------------------------------------------------

// MotorTorque

// string name = 1;
inline void MotorTorque::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MotorTorque::name() const {
  // @@protoc_insertion_point(field_get:MotorTorque.name)
  return name_.GetNoArena();
}
inline void MotorTorque::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MotorTorque.name)
}
#if LANG_CXX11
inline void MotorTorque::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MotorTorque.name)
}
#endif
inline void MotorTorque::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MotorTorque.name)
}
inline void MotorTorque::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MotorTorque.name)
}
inline ::std::string* MotorTorque::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:MotorTorque.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MotorTorque::release_name() {
  // @@protoc_insertion_point(field_release:MotorTorque.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MotorTorque::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MotorTorque.name)
}

// double torque = 2;
inline void MotorTorque::clear_torque() {
  torque_ = 0;
}
inline double MotorTorque::torque() const {
  // @@protoc_insertion_point(field_get:MotorTorque.torque)
  return torque_;
}
inline void MotorTorque::set_torque(double value) {
  
  torque_ = value;
  // @@protoc_insertion_point(field_set:MotorTorque.torque)
}

// -------------------------------------------------------------------

// MotorPID

// string name = 1;
inline void MotorPID::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MotorPID::name() const {
  // @@protoc_insertion_point(field_get:MotorPID.name)
  return name_.GetNoArena();
}
inline void MotorPID::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MotorPID.name)
}
#if LANG_CXX11
inline void MotorPID::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MotorPID.name)
}
#endif
inline void MotorPID::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MotorPID.name)
}
inline void MotorPID::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MotorPID.name)
}
inline ::std::string* MotorPID::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:MotorPID.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MotorPID::release_name() {
  // @@protoc_insertion_point(field_release:MotorPID.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MotorPID::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MotorPID.name)
}

// .Vector3 PID = 2;
inline bool MotorPID::has_pid() const {
  return this != internal_default_instance() && pid_ != NULL;
}
inline void MotorPID::clear_pid() {
  if (GetArenaNoVirtual() == NULL && pid_ != NULL) {
    delete pid_;
  }
  pid_ = NULL;
}
inline const ::Vector3& MotorPID::_internal_pid() const {
  return *pid_;
}
inline const ::Vector3& MotorPID::pid() const {
  const ::Vector3* p = pid_;
  // @@protoc_insertion_point(field_get:MotorPID.PID)
  return p != NULL ? *p : *reinterpret_cast<const ::Vector3*>(
      &::_Vector3_default_instance_);
}
inline ::Vector3* MotorPID::release_pid() {
  // @@protoc_insertion_point(field_release:MotorPID.PID)
  
  ::Vector3* temp = pid_;
  pid_ = NULL;
  return temp;
}
inline ::Vector3* MotorPID::mutable_pid() {
  
  if (pid_ == NULL) {
    auto* p = CreateMaybeMessage<::Vector3>(GetArenaNoVirtual());
    pid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MotorPID.PID)
  return pid_;
}
inline void MotorPID::set_allocated_pid(::Vector3* pid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pid_;
  }
  if (pid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pid, submessage_arena);
    }
    
  } else {
    
  }
  pid_ = pid;
  // @@protoc_insertion_point(field_set_allocated:MotorPID.PID)
}

// -------------------------------------------------------------------

// SensorTimeStep

// string name = 1;
inline void SensorTimeStep::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SensorTimeStep::name() const {
  // @@protoc_insertion_point(field_get:SensorTimeStep.name)
  return name_.GetNoArena();
}
inline void SensorTimeStep::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SensorTimeStep.name)
}
#if LANG_CXX11
inline void SensorTimeStep::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SensorTimeStep.name)
}
#endif
inline void SensorTimeStep::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SensorTimeStep.name)
}
inline void SensorTimeStep::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SensorTimeStep.name)
}
inline ::std::string* SensorTimeStep::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:SensorTimeStep.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SensorTimeStep::release_name() {
  // @@protoc_insertion_point(field_release:SensorTimeStep.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SensorTimeStep::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:SensorTimeStep.name)
}

// uint32 timeStep = 2;
inline void SensorTimeStep::clear_timestep() {
  timestep_ = 0u;
}
inline ::google::protobuf::uint32 SensorTimeStep::timestep() const {
  // @@protoc_insertion_point(field_get:SensorTimeStep.timeStep)
  return timestep_;
}
inline void SensorTimeStep::set_timestep(::google::protobuf::uint32 value) {
  
  timestep_ = value;
  // @@protoc_insertion_point(field_set:SensorTimeStep.timeStep)
}

// -------------------------------------------------------------------

// CameraQuality

// string name = 1;
inline void CameraQuality::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CameraQuality::name() const {
  // @@protoc_insertion_point(field_get:CameraQuality.name)
  return name_.GetNoArena();
}
inline void CameraQuality::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CameraQuality.name)
}
#if LANG_CXX11
inline void CameraQuality::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CameraQuality.name)
}
#endif
inline void CameraQuality::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CameraQuality.name)
}
inline void CameraQuality::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CameraQuality.name)
}
inline ::std::string* CameraQuality::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:CameraQuality.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CameraQuality::release_name() {
  // @@protoc_insertion_point(field_release:CameraQuality.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CameraQuality::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:CameraQuality.name)
}

// sint32 quality = 2;
inline void CameraQuality::clear_quality() {
  quality_ = 0;
}
inline ::google::protobuf::int32 CameraQuality::quality() const {
  // @@protoc_insertion_point(field_get:CameraQuality.quality)
  return quality_;
}
inline void CameraQuality::set_quality(::google::protobuf::int32 value) {
  
  quality_ = value;
  // @@protoc_insertion_point(field_set:CameraQuality.quality)
}

// -------------------------------------------------------------------

// CameraExposure

// string name = 1;
inline void CameraExposure::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CameraExposure::name() const {
  // @@protoc_insertion_point(field_get:CameraExposure.name)
  return name_.GetNoArena();
}
inline void CameraExposure::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CameraExposure.name)
}
#if LANG_CXX11
inline void CameraExposure::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CameraExposure.name)
}
#endif
inline void CameraExposure::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CameraExposure.name)
}
inline void CameraExposure::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CameraExposure.name)
}
inline ::std::string* CameraExposure::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:CameraExposure.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CameraExposure::release_name() {
  // @@protoc_insertion_point(field_release:CameraExposure.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CameraExposure::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:CameraExposure.name)
}

// double exposure = 2;
inline void CameraExposure::clear_exposure() {
  exposure_ = 0;
}
inline double CameraExposure::exposure() const {
  // @@protoc_insertion_point(field_get:CameraExposure.exposure)
  return exposure_;
}
inline void CameraExposure::set_exposure(double value) {
  
  exposure_ = value;
  // @@protoc_insertion_point(field_set:CameraExposure.exposure)
}

// -------------------------------------------------------------------

// ActuatorRequests

// repeated .MotorPosition motor_positions = 1;
inline int ActuatorRequests::motor_positions_size() const {
  return motor_positions_.size();
}
inline void ActuatorRequests::clear_motor_positions() {
  motor_positions_.Clear();
}
inline ::MotorPosition* ActuatorRequests::mutable_motor_positions(int index) {
  // @@protoc_insertion_point(field_mutable:ActuatorRequests.motor_positions)
  return motor_positions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MotorPosition >*
ActuatorRequests::mutable_motor_positions() {
  // @@protoc_insertion_point(field_mutable_list:ActuatorRequests.motor_positions)
  return &motor_positions_;
}
inline const ::MotorPosition& ActuatorRequests::motor_positions(int index) const {
  // @@protoc_insertion_point(field_get:ActuatorRequests.motor_positions)
  return motor_positions_.Get(index);
}
inline ::MotorPosition* ActuatorRequests::add_motor_positions() {
  // @@protoc_insertion_point(field_add:ActuatorRequests.motor_positions)
  return motor_positions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MotorPosition >&
ActuatorRequests::motor_positions() const {
  // @@protoc_insertion_point(field_list:ActuatorRequests.motor_positions)
  return motor_positions_;
}

// repeated .MotorVelocity motor_velocities = 2;
inline int ActuatorRequests::motor_velocities_size() const {
  return motor_velocities_.size();
}
inline void ActuatorRequests::clear_motor_velocities() {
  motor_velocities_.Clear();
}
inline ::MotorVelocity* ActuatorRequests::mutable_motor_velocities(int index) {
  // @@protoc_insertion_point(field_mutable:ActuatorRequests.motor_velocities)
  return motor_velocities_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MotorVelocity >*
ActuatorRequests::mutable_motor_velocities() {
  // @@protoc_insertion_point(field_mutable_list:ActuatorRequests.motor_velocities)
  return &motor_velocities_;
}
inline const ::MotorVelocity& ActuatorRequests::motor_velocities(int index) const {
  // @@protoc_insertion_point(field_get:ActuatorRequests.motor_velocities)
  return motor_velocities_.Get(index);
}
inline ::MotorVelocity* ActuatorRequests::add_motor_velocities() {
  // @@protoc_insertion_point(field_add:ActuatorRequests.motor_velocities)
  return motor_velocities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MotorVelocity >&
ActuatorRequests::motor_velocities() const {
  // @@protoc_insertion_point(field_list:ActuatorRequests.motor_velocities)
  return motor_velocities_;
}

// repeated .MotorForce motor_forces = 3;
inline int ActuatorRequests::motor_forces_size() const {
  return motor_forces_.size();
}
inline void ActuatorRequests::clear_motor_forces() {
  motor_forces_.Clear();
}
inline ::MotorForce* ActuatorRequests::mutable_motor_forces(int index) {
  // @@protoc_insertion_point(field_mutable:ActuatorRequests.motor_forces)
  return motor_forces_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MotorForce >*
ActuatorRequests::mutable_motor_forces() {
  // @@protoc_insertion_point(field_mutable_list:ActuatorRequests.motor_forces)
  return &motor_forces_;
}
inline const ::MotorForce& ActuatorRequests::motor_forces(int index) const {
  // @@protoc_insertion_point(field_get:ActuatorRequests.motor_forces)
  return motor_forces_.Get(index);
}
inline ::MotorForce* ActuatorRequests::add_motor_forces() {
  // @@protoc_insertion_point(field_add:ActuatorRequests.motor_forces)
  return motor_forces_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MotorForce >&
ActuatorRequests::motor_forces() const {
  // @@protoc_insertion_point(field_list:ActuatorRequests.motor_forces)
  return motor_forces_;
}

// repeated .MotorTorque motor_torques = 4;
inline int ActuatorRequests::motor_torques_size() const {
  return motor_torques_.size();
}
inline void ActuatorRequests::clear_motor_torques() {
  motor_torques_.Clear();
}
inline ::MotorTorque* ActuatorRequests::mutable_motor_torques(int index) {
  // @@protoc_insertion_point(field_mutable:ActuatorRequests.motor_torques)
  return motor_torques_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MotorTorque >*
ActuatorRequests::mutable_motor_torques() {
  // @@protoc_insertion_point(field_mutable_list:ActuatorRequests.motor_torques)
  return &motor_torques_;
}
inline const ::MotorTorque& ActuatorRequests::motor_torques(int index) const {
  // @@protoc_insertion_point(field_get:ActuatorRequests.motor_torques)
  return motor_torques_.Get(index);
}
inline ::MotorTorque* ActuatorRequests::add_motor_torques() {
  // @@protoc_insertion_point(field_add:ActuatorRequests.motor_torques)
  return motor_torques_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MotorTorque >&
ActuatorRequests::motor_torques() const {
  // @@protoc_insertion_point(field_list:ActuatorRequests.motor_torques)
  return motor_torques_;
}

// repeated .MotorPID motor_pids = 5;
inline int ActuatorRequests::motor_pids_size() const {
  return motor_pids_.size();
}
inline void ActuatorRequests::clear_motor_pids() {
  motor_pids_.Clear();
}
inline ::MotorPID* ActuatorRequests::mutable_motor_pids(int index) {
  // @@protoc_insertion_point(field_mutable:ActuatorRequests.motor_pids)
  return motor_pids_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MotorPID >*
ActuatorRequests::mutable_motor_pids() {
  // @@protoc_insertion_point(field_mutable_list:ActuatorRequests.motor_pids)
  return &motor_pids_;
}
inline const ::MotorPID& ActuatorRequests::motor_pids(int index) const {
  // @@protoc_insertion_point(field_get:ActuatorRequests.motor_pids)
  return motor_pids_.Get(index);
}
inline ::MotorPID* ActuatorRequests::add_motor_pids() {
  // @@protoc_insertion_point(field_add:ActuatorRequests.motor_pids)
  return motor_pids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MotorPID >&
ActuatorRequests::motor_pids() const {
  // @@protoc_insertion_point(field_list:ActuatorRequests.motor_pids)
  return motor_pids_;
}

// repeated .SensorTimeStep sensor_time_steps = 6;
inline int ActuatorRequests::sensor_time_steps_size() const {
  return sensor_time_steps_.size();
}
inline void ActuatorRequests::clear_sensor_time_steps() {
  sensor_time_steps_.Clear();
}
inline ::SensorTimeStep* ActuatorRequests::mutable_sensor_time_steps(int index) {
  // @@protoc_insertion_point(field_mutable:ActuatorRequests.sensor_time_steps)
  return sensor_time_steps_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SensorTimeStep >*
ActuatorRequests::mutable_sensor_time_steps() {
  // @@protoc_insertion_point(field_mutable_list:ActuatorRequests.sensor_time_steps)
  return &sensor_time_steps_;
}
inline const ::SensorTimeStep& ActuatorRequests::sensor_time_steps(int index) const {
  // @@protoc_insertion_point(field_get:ActuatorRequests.sensor_time_steps)
  return sensor_time_steps_.Get(index);
}
inline ::SensorTimeStep* ActuatorRequests::add_sensor_time_steps() {
  // @@protoc_insertion_point(field_add:ActuatorRequests.sensor_time_steps)
  return sensor_time_steps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SensorTimeStep >&
ActuatorRequests::sensor_time_steps() const {
  // @@protoc_insertion_point(field_list:ActuatorRequests.sensor_time_steps)
  return sensor_time_steps_;
}

// repeated .CameraQuality camera_qualities = 7;
inline int ActuatorRequests::camera_qualities_size() const {
  return camera_qualities_.size();
}
inline void ActuatorRequests::clear_camera_qualities() {
  camera_qualities_.Clear();
}
inline ::CameraQuality* ActuatorRequests::mutable_camera_qualities(int index) {
  // @@protoc_insertion_point(field_mutable:ActuatorRequests.camera_qualities)
  return camera_qualities_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::CameraQuality >*
ActuatorRequests::mutable_camera_qualities() {
  // @@protoc_insertion_point(field_mutable_list:ActuatorRequests.camera_qualities)
  return &camera_qualities_;
}
inline const ::CameraQuality& ActuatorRequests::camera_qualities(int index) const {
  // @@protoc_insertion_point(field_get:ActuatorRequests.camera_qualities)
  return camera_qualities_.Get(index);
}
inline ::CameraQuality* ActuatorRequests::add_camera_qualities() {
  // @@protoc_insertion_point(field_add:ActuatorRequests.camera_qualities)
  return camera_qualities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CameraQuality >&
ActuatorRequests::camera_qualities() const {
  // @@protoc_insertion_point(field_list:ActuatorRequests.camera_qualities)
  return camera_qualities_;
}

// repeated .CameraExposure camera_exposures = 8;
inline int ActuatorRequests::camera_exposures_size() const {
  return camera_exposures_.size();
}
inline void ActuatorRequests::clear_camera_exposures() {
  camera_exposures_.Clear();
}
inline ::CameraExposure* ActuatorRequests::mutable_camera_exposures(int index) {
  // @@protoc_insertion_point(field_mutable:ActuatorRequests.camera_exposures)
  return camera_exposures_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::CameraExposure >*
ActuatorRequests::mutable_camera_exposures() {
  // @@protoc_insertion_point(field_mutable_list:ActuatorRequests.camera_exposures)
  return &camera_exposures_;
}
inline const ::CameraExposure& ActuatorRequests::camera_exposures(int index) const {
  // @@protoc_insertion_point(field_get:ActuatorRequests.camera_exposures)
  return camera_exposures_.Get(index);
}
inline ::CameraExposure* ActuatorRequests::add_camera_exposures() {
  // @@protoc_insertion_point(field_add:ActuatorRequests.camera_exposures)
  return camera_exposures_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CameraExposure >&
ActuatorRequests::camera_exposures() const {
  // @@protoc_insertion_point(field_list:ActuatorRequests.camera_exposures)
  return camera_exposures_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Message_MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Message_MessageType>() {
  return ::Message_MessageType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_messages_2eproto
